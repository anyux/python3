# 正则表达式 ——字符串
# 和python语言，是一个独立的语法
# 是一个什么规则？？？
    # 从一个巨大的字符串集合中，
    # 根据规则来找到你想要的内容
    # 或者判断某一段字符串是否是你规定的
# 条件
    # 一个巨大的字符串
    # 规则
# 结果
    # 你想要的内容


#字符组中常用的范围
# 数字 [0-9]
# 字母 [A-Za-z]
# 数字 [A-Za-z0-9]

# 0,1
# 0,1,2,3,4,5,6,7
# 0,1,2,3,4,5,6,7,8,9,a,b,c,d,e,f

# [2\-5]
# -在字符组中有特殊的意义
# 如果你不希望它表示特殊意义，就用\进行转译
# 这样这个特殊的意义就被取消，它只表示它自己本身的意义

# 整数或小数
# 12
# 12.0
# 12.012

# '1 - 2 * ( (60-30 +-8 * 1024) - (-4*3)/ (16-3*2) )'
# while 循环
# 从这个字符串中先匹配出一个小括号
# 这个小括号里面不再有新的小括号了
# 从左到右依次匹配 乘除法
# '7.4*3'
# 首先要判断一下是除法还是乘法
# 21

import re
ret = re.findall('\d+(\.\d+)?', 'eva45.65+346[55] egon 35yuan15')
print(ret)
ret = re.findall('(\d)5', 'eva4565346[5555] egon 35yuan15')
print(ret)  # findall特性 匹配的时候按照规则匹配，显示只显示分组内的
ret = re.findall('\[(\d+)\]', 'eva4565346[555] egon 35yuan15')
print(ret)  # 在分组的开始加上?:表示取消分组优先



# ?做量词 表示0次或1次
# ?在量词后 表示惰性匹配
# ?:在分组开头 表示取消分组优先

# ret = re.search('(\d)5', 'eva4565346 egon 35yuan15')
# print(ret)
# if ret:
#     print(ret.group())
#     print(ret.group(0))
#     print(ret.group(1))
    # print(ret.group(2))
# 在search中没有正则规则的分组优先显示功能

# s = '1 - 2 * ( (60-30 +(-40/5) * (9 + 7 +10 )) - (-4*3)/ (16-3*2) )'
# print(eval(s))
# 去空格
#加减乘除 小括号算式
# 表达式的数据类型是str
# 不能用eval

# 算法 —— 中缀表达式 前缀 后缀

# 作业一定要写
# 从简单的地方开始写
# '60-30'
# 'a+b' /'a-b' /'a*b' / 'a/b'
# 首先判断是什么运算
    # '+' 以加号为分隔符 split a,b  数据类型的转换 -- 小数

# 匹配乘除法
# \d+(\.\d+)?[*/]\d+(\.\d+)?

# 整体思路
# 有一个大字符串
# 从中匹配出括号，一个内部不再有括号的表达式 —— 先算括号里的
# 匹配这小表达式中的乘除法 —— 先乘除
# 后加减

# 替换
# 匹配
# 字符串的操作
